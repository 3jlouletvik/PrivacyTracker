<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PrivacyTracker Mini App</title>
  <!--
    ОБНОВЛЁННАЯ, БЕЗОПАСНАЯ ВЕРСИЯ (MVP)
    ---------------------------------------------------
    Что сделано:
    - УБРАН ТОКЕН БОТА с клиента. Все обращения к Bot API идут через ваш бэкенд /api/*.
    - Честные кнопки «Force TCP»/«MTProto-прокси»: показывают разъяснение ограничений, не «обещают» невозможное.
    - Надёжный мэппинг звонков video_chat_started/ended по chat_id + message_id, без привязки к строкам дат.
    - Конфиденциальность: явное согласие, чётко отделены локальные данные от сетевых вызовов.
    - Обработка ошибок/ретраи, защита от дублей апдейтов (offset), контроль частоты polling.
    - Чистка «мёртвого» кода (XLSX и пр.).
    - Аккуратный UI, адаптивный, цвета из ТЗ (#0088CC, #EFEFF4, #FFFFFF).

    БЭКЕНД-ШЛЮЗ (нужен отдельно):
    - POST /api/updates { offset?: number } → { ok: true, result: Update[] }
    - POST /api/getChat { username?: string, user_id?: number } → { ok: true, result: Chat }
    - POST /api/sendMessage { chat_id, text } → { ok: true }
    Бэкенд проверяет initData Telegram WebApp и общается с Bot API, скрывая токен.
  -->
  <style>
    :root {
      --accent: #0088CC; /* основной синий */
      --bg: #EFEFF4;     /* фон */
      --card: #FFFFFF;   /* карточки */
      --text: #1f2937;   /* нейтральный тёмный */
      --muted: #6b7280;  /* серый */
      --radius: 16px;
      --shadow: 0 8px 24px rgba(0,0,0,0.08);
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      background: var(--bg); color: var(--text);
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    .container { max-width: 920px; margin: 0 auto; padding: 16px; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .title { font-size: 20px; font-weight: 700; letter-spacing: 0.2px; }
    .pill {
      display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 999px;
      background: var(--card); box-shadow: var(--shadow);
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }

    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 820px) { .grid { grid-template-columns: 1.2fr 0.8fr; } }

    .card {
      background: var(--card); border-radius: var(--radius); box-shadow: var(--shadow);
      padding: 16px;
    }
    h2 { font-size: 16px; margin: 0 0 12px; }

    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .controls .row { display: contents; }
    .controls .full { grid-column: 1 / -1; }

    button, .btn {
      appearance: none; border: 0; padding: 12px 14px; border-radius: 12px; cursor: pointer;
      background: var(--accent); color: #fff; font-weight: 600; transition: transform .08s ease, filter .2s;
    }
    button.secondary { background: #111827; }
    button.ghost { background: #e5f4fb; color: var(--accent); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: .6; cursor: not-allowed; }

    select, input[type="text"] {
      width: 100%; padding: 12px; border-radius: 12px; border: 1px solid #e5e7eb; background: #fff;
      outline: none;
    }

    .log { display: grid; gap: 8px; max-height: 320px; overflow: auto; }
    .log-item {
      background: #fff; border: 1px solid #f2f4f7; border-radius: 12px; padding: 10px 12px;
      display: flex; align-items: center; justify-content: space-between; gap: 8px;
    }
    .log-item .meta { display: flex; gap: 8px; color: var(--muted); font-size: 12px; }

    .premium-badge { margin-left: 8px; font-size: 11px; padding: 4px 8px; background: #ffe8a3; color: #6b4e00; border-radius: 999px; font-weight: 700; }

    .consent {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 50;
    }
    .consent .modal { background: #fff; border-radius: 16px; max-width: 560px; margin: 16px; padding: 18px; box-shadow: var(--shadow); }
    .consent h3 { margin: 0 0 8px; font-size: 18px; }
    .consent p { margin: 0 0 12px; color: #374151; }

    .muted { color: var(--muted); font-size: 12px; }
    .row-flex { display: flex; gap: 8px; align-items: center; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="title">PrivacyTracker <span class="muted">(Mini App)</span></div>
      <div class="pill"><span class="status-dot" id="status-dot"></span> <span id="status-text">Оффлайн</span></div>
    </header>

    <div class="grid">
      <section class="card">
        <h2>Действия</h2>
        <div class="controls">
          <div class="row">
            <button id="btn-force-tcp" class="ghost">Включить обход блокировок (TCP)</button>
            <button id="btn-proxy" class="ghost">Включить прокси <span class="premium-badge">Премиум</span></button>
          </div>
          <div class="row full">
            <button id="btn-sync" class="secondary">Синхронизировать контакты</button>
          </div>
          <div class="row full">
            <select id="contact-select"></select>
          </div>
          <div class="row">
            <input id="username-input" type="text" placeholder="@username" />
            <button id="btn-call">Позвонить</button>
          </div>
          <div class="row full">
            <button id="btn-export" class="ghost">Экспорт CSV</button>
            <button id="btn-clear" class="ghost">Очистить логи</button>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>Настройки</h2>
        <div class="row-flex">
          <label class="row-flex" style="gap:6px">
            <input type="checkbox" id="chk-premium" /> Премиум-режим (локальная симуляция)
          </label>
        </div>
        <p class="muted">Покупки не подключены в MVP. В продакшене — через Telegram Payments.</p>
      </section>
    </div>

    <section class="card" style="margin-top:12px">
      <h2>Активность</h2>
      <canvas id="chart" height="140"></canvas>
    </section>

    <section class="card" style="margin-top:12px">
      <h2>Лента</h2>
      <div id="log" class="log"></div>
    </section>
  </div>

  <!-- Согласие -->
  <div class="consent" id="consent">
    <div class="modal">
      <h3>Согласие на обработку локальных метаданных</h3>
      <p>
        Приложение локально (в вашем браузере/клиенте Telegram) отслеживает <b>метаданные</b> звонков и сообщений:
        дату, контакт, длительность звонка и счётчик сообщений. Содержимое не записывается. Часть функций (поиск
        пользователей, сервисные уведомления) обращается к нашему серверу-прокси для работы с Telegram Bot API.
      </p>
      <p class="muted">Данные логов и контактов хранятся в <code>localStorage</code> и не отправляются на наш сервер.</p>
      <div class="row-flex" style="justify-content:flex-end; margin-top:12px">
        <button id="btn-consent" class="btn">Согласен</button>
      </div>
    </div>
  </div>

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js" integrity="sha256-dtPiA8k2WalF9l7kRr7zYyqkU46H5xY2JbrM2TQ9qks=" crossorigin="anonymous"></script>
  <script>
    // --- Telegram WebApp bootstrap (мягкая деградация) ---
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) {
      try { tg.expand(); } catch(_) {}
    }

    // --- Хранилище ---
    const store = {
      get(key, def){ try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : def; } catch { return def; } },
      set(key, val){ try { localStorage.setItem(key, JSON.stringify(val)); } catch {} },
      del(key){ try { localStorage.removeItem(key); } catch {} },
    };

    const CONSENT_KEY = 'pt_consent_v1';
    const LOGS_KEY = 'pt_logs_v1'; // [{ id, type: 'call'|'msg', contact, value, dateISO }]
    const CONTACTS_KEY = 'pt_contacts_v1';
    const PREMIUM_KEY = 'pt_premium_v1';
    const OFFSET_KEY = 'pt_offset_v1'; // last processed update_id
    const ACTIVE_CALLS_KEY = 'pt_active_calls_v1'; // map by chat_id → { message_id, startISO, contact }

    // --- Состояние ---
    let logs = store.get(LOGS_KEY, []);
    let contacts = store.get(CONTACTS_KEY, []);
    let activeCalls = store.get(ACTIVE_CALLS_KEY, {});
    let lastOffset = store.get(OFFSET_KEY, 0);

    // --- Элементы ---
    const elConsent = document.getElementById('consent');
    const elBtnConsent = document.getElementById('btn-consent');
    const elSelect = document.getElementById('contact-select');
    const elBtnSync = document.getElementById('btn-sync');
    const elBtnCall = document.getElementById('btn-call');
    const elInputUsername = document.getElementById('username-input');
    const elBtnForceTCP = document.getElementById('btn-force-tcp');
    const elBtnProxy = document.getElementById('btn-proxy');
    const elChkPremium = document.getElementById('chk-premium');
    const elBtnExport = document.getElementById('btn-export');
    const elBtnClear = document.getElementById('btn-clear');
    const elLog = document.getElementById('log');
    const elStatusDot = document.getElementById('status-dot');
    const elStatusText = document.getElementById('status-text');

    // --- Утилиты ---
    const fmt = new Intl.DateTimeFormat('ru-RU', { dateStyle: 'short', timeStyle: 'short' });
    const todayKey = (d) => d.toISOString().slice(0,10); // YYYY-MM-DD

    function setOnline(on){
      elStatusDot.style.background = on ? 'var(--accent)' : '#9ca3af';
      elStatusText.textContent = on ? 'Онлайн' : 'Оффлайн';
    }

    function toast(msg){ if (tg) try { tg.showPopup({ title: 'Сообщение', message: msg, buttons:[{id:'ok', type:'default', text:'Ок'}] }); return; } catch{} alert(msg); }

    function rebuildContacts(){
      elSelect.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Выберите контакт';
      elSelect.appendChild(placeholder);
      contacts.forEach(c => {
        const o = document.createElement('option');
        o.value = String(c.user_id || c.username || '');
        o.textContent = `${c.username ? '@'+c.username : ''}${c.username && c.name ? ' — ' : ''}${c.name || ''}` || String(c.user_id);
        elSelect.appendChild(o);
      });
    }

    function pushLog(item){
      logs.unshift(item); // последний сверху
      store.set(LOGS_KEY, logs);
      renderLogs();
      refreshChart();
    }

    function renderLogs(){
      elLog.innerHTML = '';
      logs.slice(0, 300).forEach(it => {
        const row = document.createElement('div');
        row.className = 'log-item';
        const left = document.createElement('div');
        left.innerHTML = `<b>${it.type === 'call' ? 'Звонок' : 'Сообщение'}</b> — ${it.contact || 'неизв.'}`;
        const right = document.createElement('div');
        right.className = 'meta';
        const val = it.type === 'call' ? `${it.value}s` : `${it.value} шт.`;
        right.innerHTML = `<span>${val}</span><span>${fmt.format(new Date(it.dateISO))}</span>`;
        row.appendChild(left); row.appendChild(right);
        elLog.appendChild(row);
      });
    }

    // --- График ---
    let chart;
    function refreshChart(){
      const byDay = new Map(); // date → { calls: seconds, msgs: count }
      for (const it of logs){
        const key = todayKey(new Date(it.dateISO));
        if (!byDay.has(key)) byDay.set(key, { calls:0, msgs:0 });
        if (it.type === 'call') byDay.get(key).calls += Number(it.value)||0;
        else byDay.get(key).msgs += Number(it.value)||0;
      }
      const labels = Array.from(byDay.keys()).sort();
      const calls = labels.map(k => byDay.get(k).calls);
      const msgs = labels.map(k => byDay.get(k).msgs);

      const data = {
        labels,
        datasets: [
          { label: 'Звонки (сек)', data: calls, backgroundColor: '#0088CC' },
          { label: 'Сообщения (шт.)', data: msgs, backgroundColor: 'rgba(0,136,204,0.35)' }
        ]
      };

      if (!chart){
        chart = new Chart(document.getElementById('chart'), { type: 'bar', data, options: { responsive: true, scales: { x: { stacked:true }, y: { stacked:true, beginAtZero:true } } } });
      } else {
        chart.data = data; chart.update();
      }
    }

    // --- Сеть (через ваш бэкенд) ---
    const initHeaders = () => ({ 'Content-Type': 'application/json', 'X-Telegram-InitData': tg?.initData || '' });

    async function api(path, payload){
      try {
        const res = await fetch(path, { method: 'POST', headers: initHeaders(), body: JSON.stringify(payload||{}) });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const json = await res.json();
        if (!json.ok) throw new Error('API error');
        setOnline(true);
        return json.result;
      } catch (e){ setOnline(false); throw e; }
    }

    // --- Polling getUpdates ---
    let stopPolling = false; let pollingTimer = null; const POLL_MS = 1000; const RETRY_MS = 5000;

    function schedule(nextMs){ clearTimeout(pollingTimer); pollingTimer = setTimeout(poll, nextMs); }

    async function poll(){
      if (stopPolling) return;
      try {
        const updates = await api('/api/updates', { offset: lastOffset + 1 });
        if (Array.isArray(updates) && updates.length){
          for (const u of updates){ processUpdate(u); lastOffset = Math.max(lastOffset, u.update_id); }
          store.set(OFFSET_KEY, lastOffset);
        }
        schedule(POLL_MS);
      } catch (e){ schedule(RETRY_MS); }
    }

    function processUpdate(u){
      // Интересуют только message-события и сервисные видеочаты
      const msg = u.message || u.edited_message || u.channel_post; if (!msg) return;
      const chat = msg.chat || {}; const contact = chat.username ? '@'+chat.username : (chat.title || chat.first_name || 'неизв.');
      const dateISO = new Date((msg.date||Math.floor(Date.now()/1000))*1000).toISOString();

      // Сообщения пользователя (счётчик)
      if (!msg.video_chat_started && !msg.video_chat_ended){
        pushLog({ id: `msg:${u.update_id}`, type: 'msg', contact, value: 1, dateISO });
        return;
      }

      // Старт звонка
      if (msg.video_chat_started){
        const key = String(chat.id);
        activeCalls[key] = { message_id: msg.message_id, startISO: dateISO, contact };
        store.set(ACTIVE_CALLS_KEY, activeCalls);
        return;
      }

      // Окончание звонка
      if (msg.video_chat_ended){
        const key = String(chat.id);
        const started = activeCalls[key];
        if (started){
          const dur = Math.max(1, Math.floor((new Date(dateISO) - new Date(started.startISO))/1000));
          pushLog({ id: `call:${u.update_id}`, type: 'call', contact: started.contact || contact, value: dur, dateISO });
          delete activeCalls[key];
          store.set(ACTIVE_CALLS_KEY, activeCalls);
        } else {
          // Нет записи о старте — запишем минимальную длительность
          pushLog({ id: `call:${u.update_id}`, type: 'call', contact, value: msg.video_chat_ended.duration || 1, dateISO });
        }
      }
    }

    // --- Действия UI ---
    elBtnForceTCP.addEventListener('click', async () => {
      // Технически Mini App не может «включить TCP» на уровне клиента Telegram.
      // Поэтому честно объясняем и (опционально) отправляем себе подсказку от бота.
      toast('В Telegram Mini App невозможно программно включить Force TCP. Мы отправим вам инструкцию в чат.');
      try { await api('/api/sendMessage', { chat_id: tg?.initDataUnsafe?.user?.id, text: 'Инструкция по Force TCP и обходу блокировок: https://t.me/pt_docs/1' }); } catch {}
    });

    elBtnProxy.addEventListener('click', async () => {
      const premium = !!elChkPremium.checked;
      if (!premium){ toast('Доступно только в премиум-версии. Включите премиум в настройках.'); return; }
      // Мы не можем настроить MTProto прокси из WebApp. Отправим deep-link.
      const link = 'tg://proxy?server=PROXY.NET&port=443&secret=0123456789abcdef0123456789abcdef';
      toast('Нажмите ОК, чтобы открыть экран добавления прокси.');
      try { location.href = link; } catch {}
    });

    elBtnSync.addEventListener('click', async () => {
      // Telegram WebApp не выдаёт список контактов программно. Показываем честное сообщение
      toast('Telegram не предоставляет Mini App доступ к списку контактов. Введите @username вручную, либо импортируем из апдейтов.');
    });

    elBtnCall.addEventListener('click', async () => {
      const selected = elSelect.value;
      let userId = null;
      if (selected && /^\d+$/.test(selected)) userId = Number(selected);

      if (!userId){
        const uname = (elInputUsername.value || '').trim().replace(/^@/, '');
        if (!uname){ toast('Укажите @username или выберите контакт.'); return; }
        try {
          const chat = await api('/api/getChat', { username: uname });
          userId = chat.id;
        } catch (e){ toast('Пользователь не найден.'); return; }
      }

      try { location.href = `tg://user?id=${userId}`; } catch {}
      // Логируем попытку звонка
      pushLog({ id: `call:init:${Date.now()}`, type:'call', contact: `id:${userId}`, value: 0, dateISO: new Date().toISOString() });
    });

    elBtnExport.addEventListener('click', () => {
      const rows = [['Тип','Контакт','Значение','Дата']]
        .concat(logs.map(it => [it.type==='call'?'Звонок':'Сообщение', it.contact||'', String(it.value||0), new Date(it.dateISO).toISOString()]));
      const csv = rows.map(r => r.map(v => '"'+String(v).replaceAll('"','""')+'"').join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `privacytracker_${Date.now()}.csv`; a.click();
      URL.revokeObjectURL(url);
    });

    elBtnClear.addEventListener('click', () => {
      if (!confirm('Очистить локальные логи?')) return;
      logs = []; activeCalls = {}; store.set(LOGS_KEY, logs); store.set(ACTIVE_CALLS_KEY, activeCalls); renderLogs(); refreshChart();
    });

    elChkPremium.addEventListener('change', () => { store.set(PREMIUM_KEY, !!elChkPremium.checked); });

    // --- Инициализация ---
    function initFromStorage(){
      elChkPremium.checked = !!store.get(PREMIUM_KEY, false);
      rebuildContacts();
      renderLogs();
      refreshChart();
    }

    function ensureConsent(){
      const has = !!store.get(CONSENT_KEY, false);
      if (!has){ elConsent.style.display = 'flex'; document.body.style.overflow = 'hidden'; return false; }
      return true;
    }

    elBtnConsent.addEventListener('click', () => {
      store.set(CONSENT_KEY, true);
      elConsent.style.display = 'none'; document.body.style.overflow = '';
      start();
    });

    function start(){
      initFromStorage();
      if (tg) setOnline(true);
      stopPolling = false; schedule(200);
    }

    // Автозапуск
    (function(){
      initFromStorage();
      if (ensureConsent()) start();
    })();
  </script>
</body>
</html>
